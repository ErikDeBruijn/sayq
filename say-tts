#!/bin/bash
# say-tts: Text-to-speech with quality upgrade for short texts
#
# Short texts (â‰¤3000 chars): Chatterbox TTS API (better quality), macOS say fallback
# Long texts (>3000 chars): macOS say directly (no chunking complexity)
#
# Includes MacWhisper check before playback to avoid talking over the user.
#
# Usage:
#   say-tts "text to speak"
#   echo "text" | say-tts -

TTS_HOST="${TTS_HOST:-ollama.home}"
TTS_PORT="${TTS_PORT:-8880}"
TTS_VOICE="${TTS_VOICE:-dutch}"
TTS_URL="http://${TTS_HOST}:${TTS_PORT}/v1/audio/speech"
MACWHISPER_CPU_THRESHOLD=15
MACWHISPER_SETTLE_SECONDS=3
CHATTERBOX_MAX_CHARS=3000
LOG_FILE="/tmp/say-tts.log"

# Get text
if [ $# -gt 0 ] && [ "$1" != "-" ]; then
    TEXT="$*"
elif [ "$1" = "-" ]; then
    TEXT=$(cat)
else
    echo "Usage: say-tts \"text to speak\"" >&2
    exit 1
fi

[ -z "$TEXT" ] && exit 1

log() {
    echo "$(date '+%H:%M:%S') $*" >> "$LOG_FILE"
}

log "--- say-tts start: ${#TEXT} chars, url=$TTS_URL"

# Check if MacWhisper is actively transcribing (CPU > threshold)
macwhisper_is_active() {
    local pid
    pid=$(pgrep -x MacWhisper 2>/dev/null | head -1)
    [ -z "$pid" ] && return 1
    local cpu
    cpu=$(ps -p "$pid" -o %cpu= 2>/dev/null | tr -d ' ')
    [ -z "$cpu" ] && return 1
    local cpu_int=${cpu%%.*}
    [ "$cpu_int" -ge "$MACWHISPER_CPU_THRESHOLD" ]
}

# Wait for MacWhisper to finish transcribing before playing audio
wait_for_macwhisper() {
    if macwhisper_is_active; then
        log "waiting for MacWhisper..."
        while macwhisper_is_active; do
            sleep 1
        done
        sleep "$MACWHISPER_SETTLE_SECONDS"
        log "MacWhisper settled"
    fi
}

# macOS say (always works, any length)
macos_speak() {
    log "using macOS say (voice: Xander)"
    wait_for_macwhisper
    say -v Xander "$TEXT" &
    local pid=$!
    wait "$pid" 2>/dev/null
    log "macOS say done"
}

# Quick health check: is the Chatterbox server responding at all?
chatterbox_alive() {
    local code
    code=$(curl -s -o /dev/null -w "%{http_code}" \
        --connect-timeout 2 --max-time 3 \
        "$TTS_URL" 2>/dev/null)
    log "health check -> http=$code"
    [ "$code" != "000" ]
}

# Try Chatterbox TTS for short texts (better quality)
chatterbox_speak() {
    log "trying Chatterbox..."
    if ! chatterbox_alive; then
        log "Chatterbox unreachable, skipping"
        return 1
    fi

    local wav="/tmp/say-tts-$$.wav"
    trap "rm -f '$wav'" EXIT

    local json_payload
    json_payload=$(jq -n \
        --arg input "$TEXT" \
        --arg voice "$TTS_VOICE" \
        '{model:"chatterbox", input:$input, voice:$voice, response_format:"wav"}')

    log "POST $TTS_URL voice=$TTS_VOICE"
    local t0=$SECONDS
    local http_code
    http_code=$(curl -s -o "$wav" -w "%{http_code}" \
        --connect-timeout 5 --max-time 30 \
        -X POST "$TTS_URL" \
        -H "Content-Type: application/json" \
        -d "$json_payload" \
        2>/dev/null)
    local elapsed=$(( SECONDS - t0 ))
    local wav_size=0
    [ -f "$wav" ] && wav_size=$(wc -c < "$wav" | tr -d ' ')
    log "response: http=$http_code size=${wav_size}b time=${elapsed}s"

    if [ "$http_code" = "200" ] && [ -s "$wav" ]; then
        wait_for_macwhisper
        log "playing via afplay"
        afplay "$wav" &
        local pid=$!
        wait "$pid" 2>/dev/null
        log "afplay done"
        return 0
    fi

    log "Chatterbox failed (http=$http_code size=${wav_size}b), falling back"
    return 1
}

# Short text: try Chatterbox (upgrade), fall back to macOS say
# Long text: macOS say directly
if [ ${#TEXT} -le "$CHATTERBOX_MAX_CHARS" ]; then
    chatterbox_speak || macos_speak
else
    log "text too long (${#TEXT} > $CHATTERBOX_MAX_CHARS), using macOS say directly"
    macos_speak
fi

log "--- say-tts done"
